import os


def delete_unnecessary_files(dir_path):
    '''
    Given a directory path, this function deletes the images created by pixel annotation tool that we dont wan't to.
    '''
    file_names = os.listdir(dir_path)
    for file_name in file_names:
        if ('_mask' not in file_name) or ('_color_mask' in file_name):
            continue
        else:
            os.remove(dir_path + '/' + file_name)
    print('unnecessary files are deleted')



def is_dir_name_okay(dir_path):
    '''
    Given a directory path, this function checks if the directory name is valid or not. It determines this by following the convention: name_(hand no)
    '''
    def is_possible_movement(possible_num_str):
        if (possible_num_str == '0') or (possible_num_str == '1') or (possible_num_str == '2') or (possible_num_str == '3') or (possible_num_str == '4') or \
           (possible_num_str == '5') or (possible_num_str == '6') or (possible_num_str == '7') or (possible_num_str == '8') or (possible_num_str == '9') or (possible_num_str == '10'):
            return True
        else:
            return False

    parsed_dir_path = dir_path.split('/')
    dir_name = parsed_dir_path[len(parsed_dir_path) - 1]
    parsed_dir_names = dir_name.split('_')
    if not is_possible_movement(parsed_dir_names[0]):
        print(dir_name, ' is not a valid name, correct it.')
    else:
        print(dir_name, ' is a valid name.')   



def change_file_names(dir_path):
    '''
    Given a directory path, this function changes the name of the images that we need generated by pixel annotation tool.
    Naming convention follows the convention: (dir name that holds the video this frame taken from)-(frame no of the video)-(hand movement no)-(colormask.png)
    '''
    def move_color_mask_first(file_name):
        color_mask_indice = file_name.find("_color_mask")
        vid_name = file_name[:color_mask_indice]
        file_name = 'colormask-' + vid_name + '.png'
        return file_name

    def change_underscore_to_hyphen(file_name):
        k = len(file_name) - 1
        file_name = list(file_name)
        while k >= 0:
            if file_name[k] == '_':
                file_name[k] = '-'
                break
            k -= 1
        file_name = ''.join(file_name)
        return file_name

    def move_color_mask_last(file_name):
        name_without_colormask = file_name[len('-colormask'):]
        name_withour_extension = name_without_colormask[:len(name_without_colormask) - 4]
        file_name = name_withour_extension + '-colormask' + '.png'
        return file_name


    file_names = os.listdir(dir_path)
    for file_name in file_names:
        new_file_name = file_name
        if '_color_mask' in file_name:
            new_file_name = move_color_mask_first(file_name)
        new_file_name = change_underscore_to_hyphen(new_file_name)
        parsed_dir_path = dir_path.split('/')
        dir_name = parsed_dir_path[len(parsed_dir_path) - 1]
        parsed_dir_names = dir_name.split('_')
        new_file_name = new_file_name[:len(new_file_name) - 4] + '-' + parsed_dir_names[0] + new_file_name[len(new_file_name) - 4:]
        if 'colormask-' in new_file_name:
            new_file_name = move_color_mask_last(new_file_name)     

        os.rename(dir_path + '/' + file_name, dir_path + '/' + new_file_name)



def detect_missing_files(normal_dir_path, segmented_dir_path):
    '''
    Given both directories that contain normal and segmented images, this function checks if an image in either directory has its corresponding image in the other directory.
    If it does not, the image is moved to UnetDatasetProcedure/again/name_(hand no) and log file is updated.
    '''
    def check_equal_dirs(normal_dir_path, segmented_dir_path):
        normal_files = os.listdir(normal_dir_path)
        segmented_files = os.listdir(segmented_dir_path)       

        for normal_file in normal_files: 
            found = False
            normal_file = normal_file[:-4]
            for segmented_file in segmented_files:
                segmented_file = segmented_file[:-14]
                if normal_file == segmented_file:
                    found = True
                    break
            if not found:
                print(normal_file)

    normal_files = os.listdir(normal_dir_path)
    segmented_files = os.listdir(segmented_dir_path)
    copy_normal = normal_files.copy()
    copy_segmented = segmented_files.copy()
    segmented_bigger = False
    equal_file = False

    i = 0
    while i < len(normal_files):
        normal_files[i] = normal_files[i][:-4]
        i += 1

    k = 0
    while k < len(segmented_files):
        segmented_files[k] = segmented_files[k][:-14]
        k += 1

    if len(normal_files) >= len(segmented_files):
        bigger_files = normal_files
        smaller_files = segmented_files
        bigger_path = normal_dir_path
        segmented_bigger = False
    elif len(normal_files) < len(segmented_files):
        bigger_files = segmented_files
        smaller_files = normal_files
        bigger_path = segmented_dir_path
        segmented_bigger = True

    for i, bigger_file in enumerate(bigger_files):
        found = False
        for smaller_file in smaller_files:
            if smaller_file == bigger_file:
                found = True
                break
        if not found:
            parsed_bigger_path = bigger_path.split('/')

            with open("errors.log", "a") as logfile:
                if segmented_bigger:
                    logfile.write('DETECT MISSING FILES: ' + copy_segmented[i] + ' can not be found in the directory  ' + bigger_path + '\n')  
                    os.rename(bigger_path + '/' + copy_segmented[i], 'UnetDatasetProcedure/again' + '/' + parsed_bigger_path[len(parsed_bigger_path) - 1] + '/' + copy_segmented[i])
                else:
                    logfile.write('DETECT MISSING FILES: ' + copy_normal[i] + ' can not be found in the directory  ' + bigger_path + '\n')   
                    os.rename(bigger_path + '/' + copy_normal[i], 'UnetDatasetProcedure/again' + '/' + parsed_bigger_path[len(parsed_bigger_path) - 1] + '/' + copy_normal[i])
        if (i != 0) and (i % 100 == 0):
            print('100 files are processed')          








parent_dir = 'UnetDatasetProcedure'
dir_name = '1_mustafa' 
dir_path = parent_dir + '/' + dir_name

# errors.log ' u her isleme oncesi yeniden yarat ki temizlensin
delete_unnecessary_files(dir_path)
is_dir_name_okay(dir_path)
change_file_names(dir_path)
detect_missing_files('UnetDataset/normal/' + dir_name, 'UnetDataset/segmented/' + dir_name)


